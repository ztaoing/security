# 统一认证与授权
OAuth2授权标准

```
OAuth2是当前授权的行业标准，其重点在于web应用程序、桌面应用程序、移动设备、室内设备的授权流程提供简单的客户端开发方式。
他为第三方应用提供了HTTP服务的有限访问，既可以是资源拥有者通过授权允许第三方应用获取HTTP服务，也可以是第三方应用以自己的名义获取访问权限
```
# 1. 角色
* 资源所有者（resource owner）:能够对受保护的资源授予访问权限的实体，可以是一个用户，这时会被成为end-user
* 资源服务器（resource server）:持有受保护的资源，允许持有访问令牌（access token）的请求访问受保护资源
* 客户端（client）:持有资源所有的授权，代表资源所有者对受保护资源进行访问
* 授权服务器（authorization server）:对资源所有者的授权进行认证，成功后客户端发送访问令牌(很多时候，资源服务和授权服务器是合二为一的)

# 2. 协议流程
1. 客户端请求资源所有者的授权
2. 资源所有者同意授权，返回授权许可
3. 客户端携带授权许可要求授权服务器进行认证，请求访问令牌
4. 授权服务器对客户端进行身份验证，并认证授权许可；如果有效，返回令牌
5. 客户端携带访问令牌向资源服务器请求受到保护资源
6. 资源服务器验证访问令牌；如果有效，接收访问请求，返回受保护资源

# 3. 客户端授权类型
* 授权类型：授权码类型；密码类型；简化类型；客户端类型

## 1. 授权码类型：
通过重定向的方式让资源所有者直接与授权服务器来进行授权，避免了资源所有者信息泄露给客户端，是功能最完整、流程最严密的授权类型，但是需要客户端必须能与资源所有者的代理（如web浏览器）进行交互，并可从授权服务器中接收请求（重定向给授权码）

  授权码流程：
1. 客户端引导资源所有者的用户代理到授权服务器（一般通过重定向的方式），客户端提交的信息应包含客户端表示、请求范围、本地状态、用于返回授权码的重定向地址
2. 授权服务器通过用户代理认证资源所有者，并确认资源所有者允许还是拒绝客户端的访问请求
3. 如果资源所有者授予客户端访问权限，授权服务器通过重定向用户代理的方式回调客户端提供的重定向地址，并在重定向地址中添加授权码和客户端先前提供的本地状态
4. 客户端携带上一步获得的授权码，向授权服务器请求访问令牌。在这一步骤中授权码和客户端都要被授权服务器进行认证。客户端需要提交用户获取授权码的重定向地址
5. 授权服务器对客户端进行身份验证，并认证授权码，确保接收到的重定向地址与第3步中用于获取授权码的重定向地址相匹配。如果有效，则返回令牌，也有可能同时返回刷新令牌

## 2.密码类型
密码类型需要资源所有者将密码凭证交予客户端，客户端通过自己持有的信息直接向授权服务器获取授权。

授权流程：
1. 资源所有者向客户端提供其用户名和密码等凭证
2. 客户端携带资源所有者的凭证（用户名和密码），向授权服务器请求令牌
3. 授权服务器认证客户端并且验证资源所有者的凭证；如果有效，返回令牌，也有可能同时返回刷新令牌

## 3.令牌刷新
客户端从授权服务器获取的令牌一般具有实效性，在访问令牌过期的情况下，持有有效用户凭证的客户端可以再次向授权服务器请求访问令牌，而不持有用户凭证的客户端也可以通过和访问令牌一同返回的刷新令牌向授权服务器获取新的访问令牌。

# 安全传输对象JWT
JWT可以很好地充当OAuth2的访问令牌和刷新令牌的载体，这是web双方之间进行安全传输信息的良好方式。

JWT由三部分组成：
1. header 头部
2. payload 有效负载
3. signature 签名

## 1.header
header由两部分组成：
* typ 类型，一般为JWT
* alg 加密算法，通常是HMAC SHA256或RSA

一个简单的例子：

```
{
"alg":"HS256"
"typ":"JWT"
}
```
然后这部分json会被Base64Url编码用于构建JWT的第一部分
## 2.payload
是JWT的第二部分，用来携带有效信息的载体，主要是关于用户实体和附加元数据的生命，由以下三部分组成：
* 注册声明(Registered claims):他是一组预定义的声明，但是并不要求强制使用。主要有iss(JWT签发者)、exp(JWT过期时间)、sub(JWT面向的用户)、aud(接收JWT的一方)等属性信息
* 公开声明(Public claims):在公开声明中可以添加任何信息，一般是用户信息或者业务扩展信息等
* 私有声明(Private claims):他是被JWT提供者和消费者共同定义的生命，既不属于注册声明也不属于公开声明

一个简单有效的负载例子：
```
{
"sub":"1234",
"name":"xuan",
"exp":12354
}
```
 然后这部分json会被Base64Url编码用于构建JWT的第二部分
 
## 3.signature
要创建签名，必须要被编码后的头部、被编码后的有效负载以及一个secret，最后通过在头部定义的加密算法alg，加密生成签名

生成签名的伪代码如下:

```
HMACSHA256(
    base64UrlEncode(header)+"."+
    base64UrlEncode(payload),
    secret)
```
secret作为签发秘钥，用于验证JWT和签发JWT，所以只能由服务端持有，不该泄漏出去。

这是JWT的第三部分。
 
